<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>6. 内存回收(收集器种类) | 我的生活小站</title><meta name="author" content="Li Jing"><meta name="copyright" content="Li Jing"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="垃圾收集器概述垃圾收集器是垃圾回收算法（标记-清除算法、复制算法、标记-整理算法、火车算法）的具体实现，不同商家、不同版本的JVM所提供的垃圾收集器可能会有很在差别，本文主要介绍HotSpot虚拟机中的垃圾收集器。  垃圾收集器组合JDK7&#x2F;8后，HotSpot虚拟机所有收集器及组合（连线），如下图：  图中展示了7种不同分代的收集器：   Serial(串行GC)收集器 ParN">
<meta property="og:type" content="article">
<meta property="og:title" content="6. 内存回收(收集器种类)">
<meta property="og:url" content="https://ohyesc.github.io/2023/11/20/Java/Jvm/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6(%E6%94%B6%E9%9B%86%E5%99%A8%E7%A7%8D%E7%B1%BB)-gyqm04-lk5oll/index.html">
<meta property="og:site_name" content="我的生活小站">
<meta property="og:description" content="垃圾收集器概述垃圾收集器是垃圾回收算法（标记-清除算法、复制算法、标记-整理算法、火车算法）的具体实现，不同商家、不同版本的JVM所提供的垃圾收集器可能会有很在差别，本文主要介绍HotSpot虚拟机中的垃圾收集器。  垃圾收集器组合JDK7&#x2F;8后，HotSpot虚拟机所有收集器及组合（连线），如下图：  图中展示了7种不同分代的收集器：   Serial(串行GC)收集器 ParN">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-11-20T01:34:43.532Z">
<meta property="article:modified_time" content="2023-11-20T06:12:07.677Z">
<meta property="article:author" content="Li Jing">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ohyesc.github.io/2023/11/20/Java/Jvm/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6(%E6%94%B6%E9%9B%86%E5%99%A8%E7%A7%8D%E7%B1%BB)-gyqm04-lk5oll/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '6. 内存回收(收集器种类)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-20 14:12:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">125</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="我的生活小站"><span class="site-name">我的生活小站</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">6. 内存回收(收集器种类)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-20T01:34:43.532Z" title="发表于 2023-11-20 09:34:43">2023-11-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-20T06:12:07.677Z" title="更新于 2023-11-20 14:12:07">2023-11-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/">JAVA</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/JVM/">JVM</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/JVM/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/">内存回收</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="6. 内存回收(收集器种类)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer">

<p><a name="91d48814"></a></p>
<h2 id="垃圾收集器概述"><a href="#垃圾收集器概述" class="headerlink" title="垃圾收集器概述"></a>垃圾收集器概述</h2><p>垃圾收集器是垃圾回收算法（标记-清除算法、复制算法、标记-整理算法、火车算法）的具体实现，不同商家、不同版本的JVM所提供的垃圾收集器可能会有很在差别，本文主要介绍HotSpot虚拟机中的垃圾收集器。</p>
<p><a name="d1158f06"></a></p>
<h3 id="垃圾收集器组合"><a href="#垃圾收集器组合" class="headerlink" title="垃圾收集器组合"></a>垃圾收集器组合</h3><p>JDK7&#x2F;8后，HotSpot虚拟机所有收集器及组合（连线），如下图：<br><img src="https://img-blog.csdn.net/20170102225015393#align=left&display=inline&height=209&originHeight=209&originWidth=409&status=done&style=none&width=409"></p>
<ol>
<li>图中展示了7种不同分代的收集器：</li>
</ol>
<ul>
<li>Serial(串行GC)收集器</li>
<li>ParNew(并行GC)收集器</li>
<li>Parallel Scavenge(并行回收GC)收集器(串行GC)收集器</li>
<li>Serial Old(串行GC)收集器</li>
<li>Parallel Old(并行GC)收集器</li>
<li>CMS(并发GC)收集器</li>
<li>G1 JDK1.7提供的一个新收集器</li>
</ul>
<ol start="2">
<li>它们所处区域，则表明其是属于新生代收集器还是老年代收集器：</li>
</ol>
<ul>
<li>新生代收集器：Serial、ParNew、Parallel Scavenge；</li>
<li>老年代收集器：Serial Old、Parallel Old、CMS；</li>
<li>整堆收集器：G1；</li>
</ul>
<ol start="3">
<li>两个收集器间有连线，表明它们可以搭配使用</li>
<li>其中Serial Old作为CMS出现”Concurrent ModeFailure”失败的后备预案（后面介绍）</li>
</ol>
<p><a name="dc903a56"></a></p>
<h3 id="并发垃圾收集和并行垃圾收集的区别"><a href="#并发垃圾收集和并行垃圾收集的区别" class="headerlink" title="并发垃圾收集和并行垃圾收集的区别"></a>并发垃圾收集和并行垃圾收集的区别</h3><ol>
<li>并行（Parallel）<ul>
<li>指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态</li>
<li>如ParNew、Parallel Scavenge、Parallel Old</li>
</ul>
</li>
<li>并发（Concurrent）<ul>
<li>指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行）</li>
<li>用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上</li>
<li>如CMS、G1（也有并行</li>
</ul>
</li>
</ol>
<p><a name="c0768b08"></a></p>
<h3 id="Minor-GC和Full-GC的区别"><a href="#Minor-GC和Full-GC的区别" class="headerlink" title="Minor GC和Full GC的区别"></a>Minor GC和Full GC的区别</h3><ol>
<li>Minor GC<ul>
<li>又称新生代GC，指发生在新生代的垃圾收集动作</li>
<li>Java对象大多是朝生夕灭，所以Minor GC非常频繁，一般回收速度也比较快</li>
</ul>
</li>
<li>Full GC<ul>
<li>又称Major GC或老年代GC，指发生在老年代的GC</li>
<li>出现Full GC经常会伴随至少一次的Minor GC（不是绝对，Parallel Sacvenge收集器就可以选择设置Major GC策略）</li>
<li>Major GC速度一般比Minor GC慢10倍以上</li>
</ul>
</li>
</ol>
<p><a name="b5ec13f7"></a></p>
<h2 id="收集器详解"><a href="#收集器详解" class="headerlink" title="收集器详解"></a>收集器详解</h2><p>下面将介绍这些收集器的特性、基本原理和使用场景，并重点分析CMS和G1这两款相对复杂的收集器；但需要明确一个观点：</p>
<ul>
<li>没有最好的收集器，更没有万能的收集；</li>
<li>选择的只能是适合具体应用场景的收集器</li>
</ul>
<p><a name="41678ce6"></a></p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>Serial（串行）垃圾收集器是最基本、发展历史最悠久的收集器；JDK1.3.1前是HotSpot新生代收集的唯一选择</p>
<p><a name="b4d3c72e"></a></p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>针对新生代</li>
<li>采用复制算法</li>
<li>单线程收集</li>
</ol>
<p>进行垃圾收集时，必须暂停所有工作线程，直到完成。即会”Stop The World”<br><img src="https://img-blog.csdn.net/20170102225015841#align=left&display=inline&height=133&originHeight=133&originWidth=407&status=done&style=none&width=407"></p>
<p><a name="3dbf0c11"></a></p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ol>
<li>依然是HotSpot在Client模式下默认的新生代收集器</li>
<li>优于其他收集器的地方<ul>
<li>简单高效（与其他收集器的单线程相比）</li>
<li>对于限定单个CPU的环境来说，Serial收集器没有线程交互（切换）开销，可以获得最高的单线程收集效率</li>
<li>在用户的桌面应用场景中，可用内存一般不大（几十M至一两百M），可以在较短时间内完成垃圾收集（几十MS至一百多MS）,只要不频繁发生，这是可以接受的</li>
</ul>
</li>
</ol>
<p><a name="ceef9880"></a></p>
<h4 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h4><blockquote>
<p>-XX:+UseSerialGC：添加该参数来显式的使用串行垃圾收集器；</p>
</blockquote>
<p><a name="8782d809"></a></p>
<h4 id="Stop-TheWorld说明"><a href="#Stop-TheWorld说明" class="headerlink" title="Stop TheWorld说明"></a>Stop TheWorld说明</h4><p>JVM在后台自动发起和自动完成的，在用户不可见的情况下，把用户正常的工作线程全部停掉，即GC停顿</p>
<blockquote>
<p>从JDK1.3到现在，从Serial收集器-》Parallel收集器-》CMS-》G1，用户线程停顿时间不断缩短，但仍然无法完全消除</p>
</blockquote>
<p><a name="e8ec9fe0"></a></p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>arNew垃圾收集器是Serial收集器的多线程版本</p>
<p><a name="b4d3c72e-1"></a></p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol>
<li>除了多线程外，其余的行为、特点和Serial收集器一样</li>
<li>两个收集器共用了不少代码<br><img src="https://img-blog.csdn.net/20170102225016331#align=left&display=inline&height=185&originHeight=185&originWidth=475&status=done&style=none&width=475"></li>
</ol>
<p><a name="3dbf0c11-1"></a></p>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>在Server模式下，ParNew收集器是一个非常重要的收集器，因为除Serial外，目前只有它能与CMS收集器配合工作；</li>
</ul>
<p>但在单个CPU环境中，不会比Serail收集器有更好的效果，因为存在线程交互开销</p>
<p><a name="ceef9880-1"></a></p>
<h4 id="设置参数-1"><a href="#设置参数-1" class="headerlink" title="设置参数"></a>设置参数</h4><blockquote>
<p>-XX:+UseConcMarkSweepGC：指定使用CMS后，会默认使用ParNew作为新生代收集器</p>
</blockquote>
<blockquote>
<p>-XX:+UseParNewGC：强制指定使用ParNew</p>
</blockquote>
<blockquote>
<p>-XX:ParallelGCThreads：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同</p>
</blockquote>
<p><a name="314d3937"></a></p>
<h4 id="为什么只有ParNew能与CMS收集器配合"><a href="#为什么只有ParNew能与CMS收集器配合" class="headerlink" title="为什么只有ParNew能与CMS收集器配合"></a>为什么只有ParNew能与CMS收集器配合</h4><p>CMS是HotSpot在JDK1.5推出的第一款真正意义上的并发（Concurrent）收集器，第一次实现了让垃圾收集线程与用户线程（基本上）同时工作；</p>
<p>CMS作为老年代收集器，但却无法与JDK1.4已经存在的新生代收集器Parallel Scavenge配合工作；</p>
<ol>
<li>因为Parallel Scavenge（以及G1）都没有使用传统的GC收集器代码框架，而另外独立实现</li>
<li>其余几种收集器则共用了部分的框架代码</li>
</ol>
<p><a name="fc5cbdaa"></a></p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge垃圾收集器因为与吞吐量关系密切，也称为吞吐量收集器（Throughput Collector）</p>
<p><a name="b4d3c72e-2"></a></p>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ol>
<li>有一些特点与ParNew收集器相似</li>
</ol>
<ul>
<li>新生代收集器</li>
<li>采用复制算法</li>
<li>多线程收集</li>
</ul>
<ol start="2">
<li>主要特点是：它的关注点与其他收集器不同</li>
</ol>
<ul>
<li>CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间</li>
<li>Parallel Scavenge收集器的目标则是达一个可控制的吞吐量（Throughput）</li>
</ul>
<p><a name="3dbf0c11-2"></a></p>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>高吞吐量为目标，即减少垃圾收集时间，让用户代码获得更长的运行时间</li>
<li>当应用程序运行在具有多个CPU上，对暂停时间没有特别高的要求时，即程序主要在后台进行计算，而不需要与用户进行太多交互</li>
<li>例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序</li>
</ul>
<p><a name="ceef9880-2"></a></p>
<h4 id="设置参数-2"><a href="#设置参数-2" class="headerlink" title="设置参数"></a>设置参数</h4><p>Parallel Scavenge收集器提供两个参数用于精确控制吞吐量</p>
<blockquote>
<p>-XX:MaxGCPauseMillis : 控制最大垃圾收集停顿时间，大于0的毫秒数</p>
</blockquote>
<p>MaxGCPauseMillis设置得稍小，停顿时间可能会缩短，但也可能会使得吞吐量下降因为可能导致垃圾收集发生得更频繁</p>
<blockquote>
<p>-XX:GCTimeRatio : 设置垃圾收集时间占总时间的比率，0&lt;n&lt;100的整数</p>
</blockquote>
<p>GCTimeRatio相当于设置吞吐量大小；<br>垃圾收集执行时间占应用程序执行时间的比例的计算方法是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 / (1 + n)</span><br><span class="line">// 例如，选项-XX:GCTimeRatio=19，设置了垃圾收集时间占总时间的5%--1/(1+19)</span><br></pre></td></tr></table></figure>

<p>默认值是1%–1&#x2F;(1+99)，即n&#x3D;99</p>
<p>垃圾收集所花费的时间是年轻一代和老年代收集的总时间；<br>如果没有满足吞吐量目标，则增加代的内存大小以尽量增加用户程序运行的时间；</p>
<blockquote>
<p>-XX:+UseAdptiveSizePolicy</p>
</blockquote>
<p>开启这个参数后，就不用手工指定一些细节参数</p>
<blockquote>
<p>新生代的大小（-Xmn）</p>
</blockquote>
<blockquote>
<p>Eden与Survivor区的比例（-XX:SurvivorRation）</p>
</blockquote>
<blockquote>
<p>晋升老年代的对象年龄（-XX:PretenureSizeThreshold）</p>
</blockquote>
<p>JVM会根据当前系统运行情况收集性能监控信息，动态调整这些参数，以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomiscs）</p>
<p>这是一种值得推荐的方式</p>
<ol>
<li>只需设置好内存数据大小（如”-Xmx”设置最大堆）</li>
<li>然后使用”-XX:MaxGCPauseMillis”或”-XX:GCTimeRatio”给JVM设置一个优化目标</li>
<li>那些具体细节参数的调节就由JVM自适应完成</li>
</ol>
<p>这也是Parallel Scavenge收集器与ParNew收集器一个重要区别</p>
<p><a name="b88e75d0"></a></p>
<h4 id="吞吐量与收集器关注点说明"><a href="#吞吐量与收集器关注点说明" class="headerlink" title="吞吐量与收集器关注点说明"></a>吞吐量与收集器关注点说明</h4><ol>
<li>吞吐量（Throughput）</li>
</ol>
<ul>
<li>CPU用于运行用户代码的时间与CPU总消耗时间的比值；</li>
<li>即吞吐量&#x3D;运行用户代码时间&#x2F;（运行用户代码时间+垃圾收集时间）；</li>
<li>高吞吐量即减少垃圾收集时间，让用户代码获得更长的运行时间；</li>
</ul>
<ol start="2">
<li>垃圾收集器期望的目标（关注点）<ol>
<li>停顿时间<ul>
<li>停顿时间越短就适合需要与用户交互的程序</li>
<li>良好的响应速度能提升用户体验</li>
</ul>
</li>
<li>吞吐量<ul>
<li>高吞吐量则可以高效率地利用CPU时间，尽快完成运算的任务</li>
<li>主要适合在后台计算而不需要太多交互的任务；</li>
</ul>
</li>
<li>覆盖区（Footprint）<ul>
<li>在达到前面两个目标的情况下，尽量减少堆的内存空间</li>
<li>可以获得更好的空间局部性；</li>
</ul>
</li>
</ol>
</li>
</ol>
<p><a name="9d7e1dba"></a></p>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial Old是 Serial收集器的老年代版本</p>
<p><a name="b4d3c72e-3"></a></p>
<h4 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h4><ol>
<li>针对老年代</li>
<li>采用”标记-整理”算法（还有压缩，Mark-Sweep-Compact）</li>
<li>单线程收集</li>
</ol>
<p><img src="https://img-blog.csdn.net/20170102225016763#align=left&display=inline&height=133&originHeight=133&originWidth=407&status=done&style=none&width=407"></p>
<p><a name="3dbf0c11-3"></a></p>
<h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>主要用于Client模式</li>
<li>在Server模式有两大用途：<ul>
<li>在JDK1.5及之前，与Parallel Scavenge收集器搭配使用（JDK1.6有Parallel Old收集器可搭配）</li>
<li>作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用（后面详解）</li>
</ul>
</li>
</ul>
<p><a name="134300c9"></a></p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><ul>
<li>Parallel Old垃圾收集器是Parallel Scavenge收集器的老年代版本</li>
<li>JDK1.6中才开始提供</li>
</ul>
<p><a name="b4d3c72e-4"></a></p>
<h4 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h4><ol>
<li>针对老年代</li>
<li>采用”标记-整理”算法</li>
<li>多线程收集</li>
</ol>
<p><img src="https://img-blog.csdn.net/20170102225017065#align=left&display=inline&height=188&originHeight=188&originWidth=488&status=done&style=none&width=488"></p>
<p><a name="3dbf0c11-4"></a></p>
<h4 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>JDK1.6及之后用来代替老年代的Serial Old收集器</li>
<li>特别是在Server模式，多CPU的情况下</li>
<li>这样在注重吞吐量以及CPU资源敏感的场景，就有了Parallel Scavenge加Parallel Old收集器的”给力”应用组合</li>
</ul>
<p><a name="ceef9880-3"></a></p>
<h4 id="设置参数-3"><a href="#设置参数-3" class="headerlink" title="设置参数"></a>设置参数</h4><blockquote>
<p>-XX:+UseParallelOldGC ：指定使用Parallel Old收集器</p>
</blockquote>
<p><a name="835f1e24"></a></p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>并发标记清理（Concurrent Mark Sweep，CMS）收集器也称为并发低停顿收集器（Concurrent Low Pause Collector）或低延迟（low-latency）垃圾收集器</p>
<p><a name="b4d3c72e-5"></a></p>
<h4 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h4><ol>
<li>针对老年代；</li>
<li>基于”标记-清除”算法(不进行压缩操作，产生内存碎片)；</li>
<li>以获取最短回收停顿时间为目标；</li>
<li>并发收集、低停顿；</li>
<li>需要更多的内存（看后面的缺点）；</li>
</ol>
<p>是HotSpot在JDK1.5推出的第一款真正意义上的并发（Concurrent）收集器。<br>第一次实现了让垃圾收集线程与用户线程（基本上）同时工作；</p>
<p><a name="3dbf0c11-5"></a></p>
<h4 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>与用户交互较多的场景</li>
<li>希望系统停顿时间最短，注重服务的响应速度</li>
<li>以给用户带来较好的体验</li>
<li>如常见WEB、B&#x2F;S系统的服务器上的应用</li>
</ul>
<p><a name="ceef9880-4"></a></p>
<h4 id="设置参数-4"><a href="#设置参数-4" class="headerlink" title="设置参数"></a>设置参数</h4><blockquote>
<p>-XX:+UseConcMarkSweepGC ：指定使用CMS收集器</p>
</blockquote>
<p><a name="ae5bea27"></a></p>
<h4 id="CMS收集器运作过程"><a href="#CMS收集器运作过程" class="headerlink" title="CMS收集器运作过程"></a>CMS收集器运作过程</h4><p>比前面几种收集器更复杂，可以分为4个步骤:</p>
<ol>
<li>初始标记（CMS initial mark）</li>
</ol>
<ul>
<li>仅标记一下GC Roots能直接关联到的对象</li>
<li>速度很快</li>
<li>但需要”Stop The World”</li>
</ul>
<ol start="2">
<li>并发标记（CMS concurrent mark）</li>
</ol>
<ul>
<li>进行GC Roots Tracing的过程</li>
<li>刚才产生的集合中标记出存活对象</li>
<li>应用程序也在运行</li>
<li>并不能保证可以标记出所有的存活对象</li>
</ul>
<ol start="3">
<li>重新标记（CMS remark</li>
</ol>
<ul>
<li>为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录</li>
<li>需要”Stop The World”，且停顿时间比初始标记稍长，但远比并发标记短</li>
<li>采用多线程并行执行来提升效率</li>
</ul>
<ol start="4">
<li>并发清除（CMS concurrent sweep）</li>
</ol>
<ul>
<li>回收所有的垃圾对象</li>
</ul>
<p>整个过程中耗时最长的并发标记和并发清除都可以与用户线程一起工作；所以总体上说，CMS收集器的内存回收过程与用户线程一起并发执行。</p>
<p>CMS收集器运行示意图如下：<br><img src="https://img-blog.csdn.net/20170102225017372#align=left&display=inline&height=177&originHeight=177&originWidth=473&status=done&style=none&width=473"></p>
<p><a name="48771743"></a></p>
<h4 id="CMS收集器3个明显的缺点"><a href="#CMS收集器3个明显的缺点" class="headerlink" title="CMS收集器3个明显的缺点"></a>CMS收集器3个明显的缺点</h4><ol>
<li>对CPU资源非常敏感</li>
</ol>
<ul>
<li>并发收集虽然不会暂停用户线程，但因为占用一部分CPU资源，还是会导致应用程序变慢，总吞吐量降低。</li>
<li>CMS的默认收集线程数量是&#x3D;(CPU数量+3)&#x2F;4；</li>
<li>当CPU数量多于4个，收集线程占用的CPU资源多于25%，对用户程序影响可能较大；不足4个时，影响更大，可能无法接受。</li>
</ul>
<p><a name="6f40ded4"></a></p>
<h5 id="增量式并发收集器："><a href="#增量式并发收集器：" class="headerlink" title="增量式并发收集器："></a>增量式并发收集器：</h5><ul>
<li>针对这种情况，曾出现了”增量式并发收集器”（Incremental Concurrent Mark Sweep&#x2F;i-CMS）</li>
<li>类似使用抢占式来模拟多任务机制的思想，让收集线程和用户线程交替运行，减少收集线程运行时间</li>
<li>但效果并不理想，JDK1.6后就官方不再提倡用户使用</li>
</ul>
<ol start="2">
<li>无法处理浮动垃圾,可能出现”Concurrent Mode Failure”失败<ol>
<li>浮动垃圾（Floating Garbage）<ul>
<li>在并发清除时，用户线程新产生的垃圾，称为浮动垃圾</li>
<li>这使得并发清除时需要预留一定的内存空间，不能像其他收集器在老年代几乎填满再进行收集</li>
<li>可以认为CMS所需要的空间比其他垃圾收集器大</li>
<li>-XX:CMSInitiatingOccupancyFraction ：设置CMS预留内存空间</li>
<li>JDK1.5默认值为68%</li>
<li>JDK1.6变为大约92%</li>
</ul>
</li>
<li>Concurrent Mode Failure失败<ul>
<li>如果CMS预留内存空间无法满足程序需要，就会出现一次”Concurrent Mode Failure”失败</li>
<li>JVM启用后备预案：临时启用Serail Old收集器，而导致另一次Full GC的产生</li>
<li>这样的代价是很大的，所以CMSInitiatingOccupancyFraction不能设置得太大</li>
</ul>
</li>
</ol>
</li>
<li>产生大量内存碎片<br>由于CMS基于”标记-清除”算法，清除后不进行压缩操作<ol>
<li>-XX:+UseCMSCompactAtFullCollection<ul>
<li>使得CMS出现上面这种情况时不进行FullGC，而开启内存碎片的合并整理过程</li>
<li>合并整理过程无法并发，停顿时间会变长</li>
<li>默认开启（但不会进行，结合下面的CMSFullGCsBeforeCompaction）</li>
</ul>
</li>
<li>-XX:+CMSFullGCsBeforeCompaction<ul>
<li>设置执行多少次不压缩的Full GC后，来一次压缩整理</li>
<li>为减少合并整理过程的停顿时间</li>
<li>默认为0，也就是说每次都执行Full GC，不会进行压缩整理</li>
</ul>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>由于空间不再连续，CMS需要使用可用”空闲列表”内存分配方式，这比简单实用”碰撞指针”分配内存消耗大</p>
</blockquote>
<p>总体来看，与Parallel Old垃圾收集器相比，CMS减少了执行老年代垃圾收集时应用暂停的时间；<br>但却增加了新生代垃圾收集时应用暂停的时间、降低了吞吐量而且需要占用更大的堆空间</p>
<p><a name="b6099d1b"></a></p>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1（Garbage-First）是JDK7-u4才推出商用的收集器</p>
<p><a name="b4d3c72e-6"></a></p>
<h4 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h4><ol>
<li>并行与并发<ol>
<li>能充分利用多CPU、多核环境下的硬件优势</li>
<li>可以并行来缩短”Stop The World”停顿时间</li>
<li>可以并发让垃圾收集与用户程序同时进行</li>
</ol>
</li>
<li>分代收集，收集范围包括新生代和老年代<ol>
<li>能独立管理整个GC堆（新生代和老年代），而不需要与其他收集器搭配</li>
<li>能够采用不同方式处理不同时期的对象</li>
<li>虽然保留分代概念，但Java堆的内存布局有很大差别</li>
<li>将整个堆划分为多个大小相等的独立区域（Region）</li>
<li>新生代和老年代不再是物理隔离，它们都是一部分Region（不需要连续）的集合</li>
</ol>
</li>
<li>结合多种垃圾收集算法，空间整合，不产生碎片<ol>
<li>从整体看，是基于标记-整理算法</li>
<li>从局部（两个Region间）看，是基于复制算法</li>
<li>这是一种类似火车算法的实现</li>
</ol>
</li>
<li>可预测的停顿：低停顿的同时实现高吞吐量<ol>
<li>G1除了追求低停顿处，还能建立可预测的停顿时间模型</li>
<li>可以明确指定M毫秒时间片内，垃圾收集消耗的时间不超过N毫秒</li>
</ol>
</li>
</ol>
<p><a name="3dbf0c11-6"></a></p>
<h4 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h4><p>面向服务端应用，针对具有大内存、多处理器的机器；最主要的应用是为需要低G延迟，并具有大堆的应用程序提供解决方案；如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；</p>
<p>用来替换掉JDK1.5中的CMS收集器</p>
<ul>
<li>在下面的情况时，使用G1可能比CMS好：</li>
</ul>
<ol>
<li>超过50％的Java堆被活动数据占用</li>
<li>对象分配频率或年代提升频率变化很大</li>
<li>GC停顿时间过长（长于0.5至1秒）</li>
</ol>
<ul>
<li>是否一定采用G1呢？也未必：</li>
</ul>
<ol>
<li>如果现在采用的收集器没有出现问题，不用急着去选择G1</li>
<li>如果应用程序追求低停顿，可以尝试选择G1</li>
<li>是否代替CMS需要实际场景测试才知道</li>
</ol>
<p><a name="ceef9880-5"></a></p>
<h4 id="设置参数-5"><a href="#设置参数-5" class="headerlink" title="设置参数"></a>设置参数</h4><blockquote>
<p>-XX:+UseG1GC ：指定使用G1收集器</p>
</blockquote>
<blockquote>
<p>-XX:InitiatingHeapOccupancyPercent ：当整个Java堆的占用率达到参数值时，开始并发标记阶段；默认为45</p>
</blockquote>
<blockquote>
<p>-XX:MaxGCPauseMillis ：为G1设置暂停时间目标，默认值为200毫秒</p>
</blockquote>
<blockquote>
<p>-XX:G1HeapRegionSize：设置每个Region大小，范围1MB到32MB；目标是在最小Java堆时可以拥有约2048个Region</p>
</blockquote>
<p><a name="663d69ea"></a></p>
<h4 id="为什么G1收集器可以实现可预测的停顿"><a href="#为什么G1收集器可以实现可预测的停顿" class="headerlink" title="为什么G1收集器可以实现可预测的停顿"></a>为什么G1收集器可以实现可预测的停顿</h4><p>G1可以建立可预测的停顿时间模型，是因为：</p>
<ol>
<li>可以有计划地避免在Java堆的进行全区域的垃圾收集</li>
<li>G1跟踪各���Region获得其收集价值大小，在后台维护一个优先列表</li>
<li>每次根据允许的收集时间，优先回收价值最大的Region（名称Garbage-First的由来）</li>
</ol>
<p><a name="b1d6f418"></a></p>
<h4 id="一个对象被不同区域引用的问题"><a href="#一个对象被不同区域引用的问题" class="headerlink" title="一个对象被不同区域引用的问题"></a>一个对象被不同区域引用的问题</h4><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？<br>在其他的分代收集器，也存在这样的问题（而G1更突出）</p>
<ul>
<li>回收新生代也不得不同时扫描老年代？<ul>
<li>这样的话会降低Minor GC的效率</li>
</ul>
</li>
<li>解决方法：<ul>
<li>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描<ul>
<li>每个Region都有一个对应的Remembered Set，每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作</li>
<li>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）</li>
<li>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中</li>
<li>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set，就可以保证不进行全局扫描，也不会有遗漏</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a name="b9bd7d6c"></a></p>
<h4 id="G1收集器运作过程"><a href="#G1收集器运作过程" class="headerlink" title="G1收集器运作过程"></a>G1收集器运作过程</h4><p>不计算维护Remembered Set的操作，可以分为4个步骤（与CMS较为相似）</p>
<ol>
<li>初始标记（Initial Marking）</li>
</ol>
<ul>
<li>仅标记一下GC Roots能直接关联到的对象</li>
<li>且修改TAMS（Next Top at Mark Start）,让下一阶段并发运行时，用户程序能在正确可用的Region中创建新对象</li>
<li>需要”Stop The World”，但速度很快</li>
</ul>
<ol start="2">
<li>并发标记（Concurrent Marking）</li>
</ol>
<ul>
<li>进行GC Roots Tracing的过程</li>
<li>刚才产生的集合中标记出存活对象</li>
<li>耗时较长，但应用程序也在运行</li>
<li>并不能保证可以标记出所有的存活对象</li>
</ul>
<ol start="3">
<li>最终标记（Final Marking）</li>
</ol>
<ul>
<li>为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录；上一阶段对象的变化记录在线程的Remembered Set Log；这里把Remembered Set Log合并到Remembered Set中；</li>
<li>需要”Stop The World”，且停顿时间比初始标记稍长，但远比并发标记短；</li>
<li>采用多线程并行执行来提升效率；</li>
</ul>
<ol start="4">
<li>筛选回收（Live Data Counting and Evacuation）</li>
</ol>
<ul>
<li>首先排序各个Region的回收价值和成本；</li>
<li>然后根据用户期望的GC停顿时间来制定回收计划；</li>
<li>最后按计划回收一些价值高的Region中垃圾对象；</li>
<li>回收时采用”复制”算法，从一个或多个Region复制存活对象到堆上的另一个空的Region，并且在此过程中���缩和释放内存；</li>
<li>可以并发进行，降低停顿时间，并增加吞吐量；<br><img src="https://img-blog.csdn.net/20170102225017799#align=left&display=inline&height=179&originHeight=179&originWidth=485&status=done&style=none&width=485"></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ohyesc.github.io">Li Jing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ohyesc.github.io/2023/11/20/Java/Jvm/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6(%E6%94%B6%E9%9B%86%E5%99%A8%E7%A7%8D%E7%B1%BB)-gyqm04-lk5oll/">https://ohyesc.github.io/2023/11/20/Java/Jvm/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6(%E6%94%B6%E9%9B%86%E5%99%A8%E7%A7%8D%E7%B1%BB)-gyqm04-lk5oll/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ohyesc.github.io" target="_blank">我的生活小站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/20/Java/Jvm/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6(%E6%94%B6%E9%9B%86%E5%99%A8%E6%A8%A1%E5%BC%8F)-gyqm04-hy7sdx/" title="5. 内存回收(收集器模式)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">5. 内存回收(收集器模式)</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/20/Java/Jvm/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6(%E6%96%B0%E7%94%9F%E4%BB%A3%E3%80%81%E8%80%81%E7%94%9F%E4%BB%A3)-gyqm04-dhre0s/" title="7. 内存回收(新生代、老生代)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">7. 内存回收(新生代、老生代)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/20/Java/Jvm/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/JAVA%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-gyqm04-rlzkaf/" title="1. JAVA代码执行机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-20</div><div class="title">1. JAVA代码执行机制</div></div></a></div><div><a href="/2023/11/20/Java/Jvm/%E7%B1%BB%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8DTLAB-gyqm04-yi6cz0/" title="1. 内存分配TLAB"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-20</div><div class="title">1. 内存分配TLAB</div></div></a></div><div><a href="/2023/11/20/Java/Jvm/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/JVM%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE-gyqm04-ewlmi1/" title="1. JVM常见配置"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-20</div><div class="title">1. JVM常见配置</div></div></a></div><div><a href="/2023/11/20/Java/Jvm/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%A4%E4%BA%92/JVM%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6-gyqm04-gbbwey/" title="1. JVM线程同步机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-20</div><div class="title">1. JVM线程同步机制</div></div></a></div><div><a href="/2023/11/20/Java/Jvm/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E5%88%86%E6%9E%90-gyqm04-uvhai7/" title="1. 性能瓶颈分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-20</div><div class="title">1. 性能瓶颈分析</div></div></a></div><div><a href="/2023/11/20/Java/Jvm/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/Java%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E7%AE%80%E8%BF%B0-gyqm04-rs3maz/" title="2. Java代码编译过程简述"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-20</div><div class="title">2. Java代码编译过程简述</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Li Jing</div><div class="author-info__description">这是一个老父亲答应给孩子建个网站，记录一下他的成长</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">125</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">垃圾收集器概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%BB%84%E5%90%88"><span class="toc-number">1.1.</span> <span class="toc-text">垃圾收集器组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%92%8C%E5%B9%B6%E8%A1%8C%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">并发垃圾收集和并行垃圾收集的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Minor-GC%E5%92%8CFull-GC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">Minor GC和Full GC的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">收集器详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">Serial收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">2.1.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.1.2.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">2.1.3.</span> <span class="toc-text">设置参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Stop-TheWorld%E8%AF%B4%E6%98%8E"><span class="toc-number">2.1.4.</span> <span class="toc-text">Stop TheWorld说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">ParNew收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0-1"><span class="toc-number">2.2.3.</span> <span class="toc-text">设置参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E6%9C%89ParNew%E8%83%BD%E4%B8%8ECMS%E6%94%B6%E9%9B%86%E5%99%A8%E9%85%8D%E5%90%88"><span class="toc-number">2.2.4.</span> <span class="toc-text">为什么只有ParNew能与CMS收集器配合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text">Parallel Scavenge收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">2.3.2.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0-2"><span class="toc-number">2.3.3.</span> <span class="toc-text">设置参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E4%B8%8E%E6%94%B6%E9%9B%86%E5%99%A8%E5%85%B3%E6%B3%A8%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="toc-number">2.3.4.</span> <span class="toc-text">吞吐量与收集器关注点说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.4.</span> <span class="toc-text">Serial Old收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-3"><span class="toc-number">2.4.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="toc-number">2.4.2.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.5.</span> <span class="toc-text">Parallel Old收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-4"><span class="toc-number">2.5.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="toc-number">2.5.2.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0-3"><span class="toc-number">2.5.3.</span> <span class="toc-text">设置参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.6.</span> <span class="toc-text">CMS收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-5"><span class="toc-number">2.6.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-5"><span class="toc-number">2.6.2.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0-4"><span class="toc-number">2.6.3.</span> <span class="toc-text">设置参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.6.4.</span> <span class="toc-text">CMS收集器运作过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A83%E4%B8%AA%E6%98%8E%E6%98%BE%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">2.6.5.</span> <span class="toc-text">CMS收集器3个明显的缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%BC%8F%E5%B9%B6%E5%8F%91%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%9A"><span class="toc-number">2.6.5.1.</span> <span class="toc-text">增量式并发收集器：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.7.</span> <span class="toc-text">G1收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-6"><span class="toc-number">2.7.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-6"><span class="toc-number">2.7.2.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0-5"><span class="toc-number">2.7.3.</span> <span class="toc-text">设置参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88G1%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E5%8F%AF%E9%A2%84%E6%B5%8B%E7%9A%84%E5%81%9C%E9%A1%BF"><span class="toc-number">2.7.4.</span> <span class="toc-text">为什么G1收集器可以实现可预测的停顿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%B8%8D%E5%90%8C%E5%8C%BA%E5%9F%9F%E5%BC%95%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.7.5.</span> <span class="toc-text">一个对象被不同区域引用的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.7.6.</span> <span class="toc-text">G1收集器运作过程</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/20/Mybatis/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/1.%20%E9%85%8D%E7%BD%AE%E2%BD%82%E4%BB%B6%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90-hyw7ef-geagn5/" title="1. 配置⽂件解析过程分析">1. 配置⽂件解析过程分析</a><time datetime="2023-11-20T01:36:07.251Z" title="发表于 2023-11-20 09:36:07">2023-11-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/20/Mybatis/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/2.%20%E8%A7%A3%E6%9E%90properties%E8%8A%82%E7%82%B9-hyw7ef-er4viw/" title="2. 解析properties节点">2. 解析properties节点</a><time datetime="2023-11-20T01:36:06.717Z" title="发表于 2023-11-20 09:36:06">2023-11-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/20/Mybatis/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/3.%20%E8%A7%A3%E6%9E%90settings%E8%8A%82%E7%82%B9-hyw7ef-diq3xg/" title="3. 解析settings节点">3. 解析settings节点</a><time datetime="2023-11-20T01:36:06.171Z" title="发表于 2023-11-20 09:36:06">2023-11-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/20/Mybatis/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/4.%20%E8%AE%BE%E7%BD%AEsettings%E5%86%85%E5%AE%B9%E5%88%B0%20Configuration%E4%B8%AD-hyw7ef-axg91r/" title="4. 设置settings内容到 Configuration中">4. 设置settings内容到 Configuration中</a><time datetime="2023-11-20T01:36:05.477Z" title="发表于 2023-11-20 09:36:05">2023-11-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/20/Mybatis/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/5.%20%E8%A7%A3%E6%9E%90typeAliases%E8%8A%82%E7%82%B9-hyw7ef-txspfu/" title="5. 解析typeAliases节点">5. 解析typeAliases节点</a><time datetime="2023-11-20T01:36:05.110Z" title="发表于 2023-11-20 09:36:05">2023-11-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Li Jing</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>