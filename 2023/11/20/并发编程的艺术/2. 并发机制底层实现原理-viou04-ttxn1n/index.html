<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>2. 并发机制底层实现原理 | 我的生活小站</title><meta name="author" content="Li Jing"><meta name="copyright" content="Li Jing"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JAVA代码编译后会变成JAVA字节码，字节码被类加载器加载到JVM中，JVM执行字节码，最终需要转换为汇编指令在CPU上执行。 JAVA中使用的并发机制，依赖于JVM的实现和CPU的指令  volatile的应用它比synchronized使用执行成本更低，因为它不会引起线程上下文切换和调度。  volatile定义和原理   属于 英文单词 描述    内存屏障 memory barrie">
<meta property="og:type" content="article">
<meta property="og:title" content="2. 并发机制底层实现原理">
<meta property="og:url" content="https://ohyesc.github.io/2023/11/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/2.%20%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-viou04-ttxn1n/index.html">
<meta property="og:site_name" content="我的生活小站">
<meta property="og:description" content="JAVA代码编译后会变成JAVA字节码，字节码被类加载器加载到JVM中，JVM执行字节码，最终需要转换为汇编指令在CPU上执行。 JAVA中使用的并发机制，依赖于JVM的实现和CPU的指令  volatile的应用它比synchronized使用执行成本更低，因为它不会引起线程上下文切换和调度。  volatile定义和原理   属于 英文单词 描述    内存屏障 memory barrie">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-11-20T01:33:29.070Z">
<meta property="article:modified_time" content="2023-11-20T03:04:48.675Z">
<meta property="article:author" content="Li Jing">
<meta property="article:tag" content="并发编程的艺术">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ohyesc.github.io/2023/11/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/2.%20%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-viou04-ttxn1n/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2. 并发机制底层实现原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-20 11:04:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">125</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="我的生活小站"><span class="site-name">我的生活小站</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">2. 并发机制底层实现原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-20T01:33:29.070Z" title="发表于 2023-11-20 09:33:29">2023-11-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-20T03:04:48.675Z" title="更新于 2023-11-20 11:04:48">2023-11-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/">JAVA</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%89%8D%E8%A8%80/">前言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="2. 并发机制底层实现原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer">

<p>JAVA代码编译后会变成JAVA字节码，字节码被类加载器加载到JVM中，JVM执行字节码，最终需要转换为汇编指令在CPU上执行。</p>
<p>JAVA中使用的并发机制，依赖于JVM的实现和CPU的指令</p>
<p><a name="f55dd1b3"></a></p>
<h2 id="volatile的应用"><a href="#volatile的应用" class="headerlink" title="volatile的应用"></a>volatile的应用</h2><p>它比synchronized使用执行成本更低，因为它不会引起线程上下文切换和调度。</p>
<p><a name="7cc7c13a"></a></p>
<h3 id="volatile定义和原理"><a href="#volatile定义和原理" class="headerlink" title="volatile定义和原理"></a>volatile定义和原理</h3><table>
<thead>
<tr>
<th>属于</th>
<th>英文单词</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>内存屏障</td>
<td>memory barriers</td>
<td>一组处理器指令，实现对内存操作的顺序限制</td>
</tr>
<tr>
<td>缓冲行</td>
<td>cache line</td>
<td>缓存中可以分配的最小存储单��</td>
</tr>
<tr>
<td>原子操作</td>
<td>atomic operations</td>
<td>不可中断的一个或一系列操作</td>
</tr>
<tr>
<td>缓冲行填充</td>
<td>cache line fill</td>
<td>当处理器识别从内存中读取操作数是可缓存的，处理器读取整合缓冲行到合适的内存(L1,L2,L3或所有)</td>
</tr>
<tr>
<td>缓存命中</td>
<td>cache hit</td>
<td>如果进行高速缓存行操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存读取数据，而不是从内存</td>
</tr>
<tr>
<td>写命中</td>
<td>write hit</td>
<td>当处理器将操作数写回到一个内存缓存的区域时，会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效缓存行，则处理器将操作数写回到缓存，而不是写回内存，这个操作成为写命中</td>
</tr>
<tr>
<td>写缺失</td>
<td>write misses the cache</td>
<td>一个有效的缓存行被写入到不存在的内存区域</td>
</tr>
</tbody></table>
<p>有volatile变量修饰的共享变量，进行写操作时，lock前缀的命令在多核处理器下引发两件事：</p>
<ol>
<li>将当前处理器缓存行的数据写回到主内存</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效</li>
</ol>
<p>多核处理器下，为了保证各个处理器的缓存是一致的：就会实现一个一致性协议，每个处理器通过嗅探在总线上传播的数据，来检查自己缓存的值是否过期。当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设为无效状态。处理器对改数据进行操作时，会重新从主内存读取到缓存行中</p>
<p><a name="8eb9138c"></a></p>
<h4 id="volatile实现原则："><a href="#volatile实现原则：" class="headerlink" title="volatile实现原则："></a>volatile实现原则：</h4><ul>
<li>lock前缀指令会引起处理器缓存回写到内存 <ul>
<li>多线程环境中，lock#信号确保在声言该信号期间，处理器可以独占任何共享内存</li>
<li>最近的处理器中，一般不锁总线，而是锁缓存，因为总线消耗大</li>
<li>锁缓存，使用缓存一致性协议确保修改的原子性</li>
</ul>
</li>
<li>一个处理器的缓存回写到内存会导致其他处理器缓存无效 <ul>
<li>强制实行缓存行填充</li>
</ul>
</li>
</ul>
<p><a name="8d8255e1"></a></p>
<h4 id="volatile的使用优化："><a href="#volatile的使用优化：" class="headerlink" title="volatile的使用优化："></a>volatile的使用优化：</h4><p>LinkedTransferQueue，使用volatile时，用一种追加字节的方式来优化队列出队和入队的性能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 队列中的头部节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> PaddedAtomicReference&lt;QNode&gt; head;</span><br><span class="line"><span class="comment">/** 队列中的尾部节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">final</span> PaddedAtomicReference&lt;QNode&gt; tail;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PaddedAtomicReference</span> &lt;T&gt; <span class="keyword">extends</span> <span class="title class_">AtomicReference</span> T&gt; &#123;</span><br><span class="line">    <span class="comment">// 使用很多4个字节的引用追加到64个字节</span></span><br><span class="line">    Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe;</span><br><span class="line">    PaddedAtomicReference(T r) &#123;</span><br><span class="line">        <span class="built_in">super</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicReference</span> &lt;V&gt; <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<p><a name="63b72a99"></a></p>
<h5 id="追加字节能优化性能？"><a href="#追加字节能优化性能？" class="headerlink" title="追加字节能优化性能？"></a>追加字节能优化性能？</h5><p>LinkedTransferQueue这个类，它使用一个内部类类型来定义队列的<br>头节点（head）和尾节点（tail），而这个内部类PaddedAtomicReference相对于父类AtomicReference只做了一件事情，就是将共享变量追加到64字节。我们可以来计算下：</p>
<blockquote>
<p>一个对象的引用占4个字节，它追加了15个变量（共占60个字节），再加上父类的value变量，一共64个字节</p>
</blockquote>
<p><a name="8213e716"></a></p>
<h5 id="为什么追加64字节能够提高并发编程的效率呢？"><a href="#为什么追加64字节能够提高并发编程的效率呢？" class="headerlink" title="为什么追加64字节能够提高并发编程的效率呢？"></a>为什么追加64字节能够提高并发编程的效率呢？</h5><p>因为对于英特尔酷睿i7、酷睿、Atom和NetBurst，以及CoreSolo和PentiumM处理器的L1、L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行</p>
<p>这意味着，如果队列的头节点和尾节点都不足64字节的话，处理器会将它们都读到同一个高速缓存行中，在多处理器下每个处理器都会缓存同样的头、尾节点，当一个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操作则需要不停修改头节点和尾节点，所以在多处理器的情况下将会严重影响到队列的入队和出队效率。</p>
<p>Doug lea使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定</p>
<p><a name="901b644a"></a></p>
<h5 id="那么是不是在使用volatile变量时都应该追加到64字节呢？"><a href="#那么是不是在使用volatile变量时都应该追加到64字节呢？" class="headerlink" title="那么是不是在使用volatile变量时都应该追加到64字节呢？"></a>那么是不是在使用volatile变量时都应该追加到64字节呢？</h5><p>不是的</p>
<p><a name="8b516c81"></a></p>
<h6 id="缓存行非64字节宽的处理器"><a href="#缓存行非64字节宽的处理器" class="headerlink" title="缓存行非64字节宽的处理器"></a>缓存行非64字节宽的处理器</h6><p>P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个字节宽</p>
<p><a name="3dea04f7"></a></p>
<h6 id="共享变量不会被频繁地写。"><a href="#共享变量不会被频繁地写。" class="headerlink" title="共享变量不会被频繁地写。"></a>共享变量不会被频繁地写。</h6><p>因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定</p>
<p><a name="61a4322c"></a></p>
<h2 id="synchronized的实现原理与应用"><a href="#synchronized的实现原理与应用" class="headerlink" title="synchronized的实现原理与应用"></a>synchronized的实现原理与应用</h2><p>先来看下利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现<br>为以下3种形式。</p>
<ul>
<li>对于普通同步方法，锁是当前实例对象。</li>
<li>对于静态同步方法，锁是当前类的Class对象。</li>
<li>对于同步方法块，锁是Synchonized括号里配置的对象</li>
</ul>
<p>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样</p>
<ul>
<li>代码块同步是使用monitorenter和monitorexit指令实现的</li>
<li>方法同步是使用另外一种方式实现。但是，方法的同步同样可以使用这两个指令来实现。</li>
<li>monitorenter指令是在编译后插入到同步代码块的开始位置</li>
<li>monitorexit是插入到方法结束处和异常处</li>
</ul>
<p>JVM要保证每个monitorenter必须有对应的monitorexit与之配对。</p>
<p>任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁</p>
<p><a name="6103349d"></a></p>
<h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>对象在内存中存储的布局可以分为3块区域：对象头（Header），实例数据（Instance Data）和对齐填充（Padding）</p>
<p>也就是说  JAVA对象 &#x3D; 对象头 + 实例数据 + 对象填充</p>
<p>对象头由两部分组成，一部分用于存储自身的运行时数据，称之为 Mark Word，另外一部分是类型指针，及对象指向它的类元数据的指针。</p>
<p>对象头 &#x3D; Mark Word + 类型指针</p>
<p>（未开启指针压缩的情况下）</p>
<ul>
<li>在32位系统中，Mark Word &#x3D; 4 bytes &#x3D; 32 bits，对象头 &#x3D; 8 bytes &#x3D; 64 bits</li>
<li>在64位系统中，Mark Word &#x3D; 8 bytes &#x3D; 64 bits ，对象头 &#x3D; 16 bytes &#x3D; 128bits</li>
</ul>
<p>synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。</p>
<p><a name="244dc59d"></a></p>
<h4 id="32位虚拟机和64位虚拟机对象头"><a href="#32位虚拟机和64位虚拟机对象头" class="headerlink" title="32位虚拟机和64位虚拟机对象头"></a>32位虚拟机和64位虚拟机对象头</h4><table>
<thead>
<tr>
<th>长度</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>32&#x2F;64bit</td>
<td>Mark Word</td>
<td>存储对象的hashCode或锁信息</td>
</tr>
<tr>
<td>32&#x2F;64bit</td>
<td>Class Metadata Address</td>
<td>存储到对象类型数据的指针</td>
</tr>
<tr>
<td>32&#x2F;64bit</td>
<td>Array Length</td>
<td>数组的长度(如果当前对象是数组)</td>
</tr>
</tbody></table>
<p>Java对象头里的Mark Word里默认存储对象的HashCode、分代年龄和锁标记位。</p>
<p><a name="f88cecf9"></a></p>
<h4 id="JAVA对象头存储结构"><a href="#JAVA对象头存储结构" class="headerlink" title="JAVA对象头存储结构"></a>JAVA对象头存储结构</h4><table>
<thead>
<tr>
<th>锁状态</th>
<th>25bit</th>
<th>4bit</th>
<th>1bit是否是偏向锁</th>
<th>2bit锁标志位</th>
</tr>
</thead>
<tbody><tr>
<td>无锁状态</td>
<td>对象的hashCode</td>
<td>对象的分代年龄</td>
<td>0</td>
<td>01</td>
</tr>
</tbody></table>
<p>在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变<br>化为存储以下4种数据<br><img src="https://img-blog.csdn.net/20180518151408659#id=EDQcA&originHeight=347&originWidth=999&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>在64位虚拟机下，Mark Word是64bit大小的，其存储结构如下：</p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>25bit</th>
<th>31bit</th>
<th>1bit</th>
<th>4bit</th>
<th>1bit</th>
<th>2bit</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><br></td>
<td><br></td>
<td>cms_free</td>
<td>分代年龄</td>
<td>偏向锁</td>
<td>锁标志位</td>
</tr>
<tr>
<td>无锁</td>
<td>unused</td>
<td>hashCode</td>
<td><br></td>
<td><br></td>
<td>0</td>
<td>01</td>
</tr>
<tr>
<td>偏向锁</td>
<td>ThreadID(54bit) Epoch(2bit)</td>
<td></td>
<td><br></td>
<td><br></td>
<td>1</td>
<td>01</td>
</tr>
</tbody></table>
<p><a name="0574f609"></a></p>
<h3 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h3><p>类型指针即代表对象指向它的类元数据的指针，虚拟机通过这个指针来确定该对象是哪个类的实例。</p>
<p>但查找对象的元数据信息并不一定要经过对象本身。如果对象是一个Java数组，在对象头中还须有一块用于记录数组长度的数据，因为虚拟机可通过普通Java对象的元数据信息确定Java对象的大小，但从数组的元数据中无法确定数组的大小。</p>
<p><a name="4d39431e"></a></p>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>真正存储有效信息，即程序代码中所定义的各种类型的字段内容，包括父类继承下来的和子类定义的。这部分存储顺序受虚拟机分配策略参数（FiledsAllocationStyle)和字段在Java源码中定义的顺序的影响。</p>
<p>HotSpot虚拟机默认分配策略为longs&#x2F;double、ints、shorts&#x2F;chars、bytes&#x2F;booleans、oops(Ordinary ObjectPointers)，从分配策略可以看出，相同宽度的字段总是被分配到一起。</p>
<p>在此前提条件下，父类中定义的变量会出在子类之前，若CompactFileds的参数值为true，那么子类中较窄的变量也可能会插到父类变量的空隙中。</p>
<p>原生类型(primitive type)的内存占用如下：</p>
<table>
<thead>
<tr>
<th>Primitive Type</th>
<th>Memory Required(bytes)</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>1</td>
</tr>
<tr>
<td>byte</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
</tr>
</tbody></table>
<p>reference类型在32位系统上每个占用4bytes, 在64位系统上每个占用8bytes</p>
<p><a name="944c1653"></a></p>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>对齐填充并不是必然存在的，也没有什么特别的意义，他仅仅起着占位符的作用，由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是</p>
<ul>
<li>对象的大小必须是8字节的整数倍。-</li>
<li>对象头正好是8字节的倍数</li>
<li>因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</li>
</ul>
<p><a name="48207286"></a></p>
<h3 id="锁的升级与对比"><a href="#锁的升级与对比" class="headerlink" title="锁的升级与对比"></a>锁的升级与对比</h3><p>Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。</p>
<p>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是 为了提高获得锁和释放锁的效率</p>
<p><a name="b95229b3"></a></p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的MarkWord里是否存储着指向当前线程的偏向锁。</p>
<ul>
<li>测试成功，表示线程已经获��了锁。</li>
<li>测试失败，则需要再测试一下MarkWord中偏向锁的标识是否设置成1（表示当前是偏向锁） <ul>
<li>没有设置，则使用CAS竞争锁；</li>
<li>设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</li>
</ul>
</li>
</ul>
<p><a name="28a25b6d"></a></p>
<h6 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h6><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）</p>
<ul>
<li>首先暂停拥有偏向锁的线程</li>
<li>然后检查持有偏向锁的线程是否活着 <ul>
<li>线程不处于活动状态，则将对象头设置成无锁状态</li>
<li>线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中锁记录和对象头的MarkWord <ul>
<li>要么重新偏向于其他线程</li>
<li>要么恢复到无锁或者标记对象不适合作为偏向锁</li>
</ul>
</li>
</ul>
</li>
<li>最后唤醒暂停的线程</li>
</ul>
<p>流程<br><img src="https://ask.qcloudimg.com/http-save/yehe-1174983/qeqp98u8so.png?imageView2/2/w/1620#id=YtiHw&originHeight=551&originWidth=722&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1174983/cm2p35nftf.png?imageView2/2/w/1620#id=H3ybT&originHeight=969&originWidth=865&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><a name="f497891d"></a></p>
<h6 id="关闭偏向锁"><a href="#关闭偏向锁" class="headerlink" title="关闭偏向锁"></a>关闭偏向锁</h6><p>偏向锁在Java 6和Java7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay&#x3D;0。</p>
<p>如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking&#x3D;false，那么程序默认会进入轻量级锁状态</p>
<p><a name="2df05795"></a></p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p><a name="2daf563b"></a></p>
<h5 id="轻量级锁加锁"><a href="#轻量级锁加锁" class="headerlink" title="轻量级锁加锁"></a>轻量级锁加锁</h5><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的MarkWord复制到锁记录中，官方称为DisplacedMarkWord。然后线程尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<ol>
<li>在MarkWord中保存当前线程的指针</li>
<li>修改锁标识位为“00”</li>
</ol>
<p>采用CAS操作的原因是，不想在加锁解锁上再加同步</p>
<p>如果对象处于无锁状态（偏向锁标志位为”0”，锁标志位为”01”），会在线程的栈中开辟个锁记录空间（LockRecord），将MarkWord拷贝一份到LockRecord中，称为Displaced Mark Word，在Lock Record中保存对象头的指针（owner）。</p>
<p>接下来CAS更新MarkWord，将MarkWord指向当前线程，owner指向MarkWord，如果失败了，则意味着出现了另一个线程竞争锁，此时需要锁膨胀为轻量级锁。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1174983/hr3330qo7g.png?imageView2/2/w/1620#id=AltNA&originHeight=276&originWidth=561&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1174983/acgacyts24.png?imageView2/2/w/1620#id=AEo3G&originHeight=397&originWidth=576&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><a name="eda0b47d"></a></p>
<h5 id="轻量级锁解锁"><a href="#轻量级锁解锁" class="headerlink" title="轻量级锁解锁"></a>轻量级锁解锁</h5><p>轻量级解锁时，会使用原子的CAS操作将DisplacedMarkWord替换回到对象头，</p>
<ul>
<li>如果成功，则表示没有竞争发生。</li>
<li>如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。<br><img src="https://ask.qcloudimg.com/http-save/yehe-1174983/ro5yr0z6y9.png?imageView2/2/w/1620#id=MsdEx&originHeight=840&originWidth=865&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></li>
</ul>
<p>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线��试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p>
<p><a name="99cac350"></a></p>
<h4 id="锁的优缺点对比"><a href="#锁的优缺点对比" class="headerlink" title="锁的优缺点对比"></a>锁的优缺点对比</h4><table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td>如果线程之间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块场景</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到锁竞争的线程，使用自旋会消耗CPU</td>
<td>追求响应时间， 同步块执行速度非常快</td>
</tr>
<tr>
<td>重量级锁</td>
<td>锁竞争不使用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量，同步块执行时间较长</td>
</tr>
</tbody></table>
<p><a name="055d0696"></a></p>
<h2 id="原子操作的实现原理"><a href="#原子操作的实现原理" class="headerlink" title="原子操作的实现原理"></a>原子操作的实现原理</h2><p><a name="76f8c78d"></a></p>
<h3 id="CPU术语定义"><a href="#CPU术语定义" class="headerlink" title="CPU术语定义"></a>CPU术语定义</h3><table>
<thead>
<tr>
<th>术语名称</th>
<th>英文</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>缓存行</td>
<td>Cache line</td>
<td>缓存的最小单位</td>
</tr>
<tr>
<td>比较并交换</td>
<td>Compare and Swap</td>
<td>CAS操作需要输入两个值，一个旧值(期望操作前的值)，一个新值，在操作期间先比较旧值有没有发生变化，如果没有，才交换生成新值，发生了变化则不交换</td>
</tr>
<tr>
<td>CPU流水线</td>
<td>CPU pipeline</td>
<td>CPU流水线的工作方式就像是工业流水线，在CPU中由56个不同功能的电路单元组成一条指令处理流水线，然后将一条X86指令分成56步，再由这些电路单元分别执行。 这样就能在一个时钟周期内完成一个指令，提高CPU运转速度</td>
</tr>
<tr>
<td>内存顺序冲突</td>
<td>Memory order violation</td>
<td>内存顺序冲突是由假共享引起的，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效，当出现内存顺序冲突时，CPU必须清空流水线</td>
</tr>
</tbody></table>
<p><a name="aad0489e"></a></p>
<h3 id="处理器如何实现原子操作"><a href="#处理器如何实现原子操作" class="headerlink" title="处理器如何实现原子操作"></a>处理器如何实现原子操作</h3><p>32位IA-32处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。</p>
<p>首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。</p>
<p>Pentium 6和最新的处理器能自动保证单处理器对同一个缓存行里进行16&#x2F;32&#x2F;64位<br>的操作是原子的，但是复杂的内存操作处理器是不能自动保证其原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p>
<p><a name="4c503fde"></a></p>
<h4 id="使用总线锁保证原子性"><a href="#使用总线锁保证原子性" class="headerlink" title="使用总线锁保证原子性"></a>使用总线锁保证原子性</h4><p>如果多个处理器同时对共享变量进行读改写操作（i++就是经典的读改写操作），那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致</p>
<p>原因可能是多个处理器同时从各自的缓存中读取变量i，分别进行加1操作，然后分别写入系统内存中。那么，想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。</p>
<p>处理器使用总线锁就是来解决这个问题的。所谓总线锁就是使用处理器提供的一个<br>LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存</p>
<p><a name="38ef1d8d"></a></p>
<h4 id="使用缓存锁保证原子性"><a href="#使用缓存锁保证原子性" class="headerlink" title="使用缓存锁保证原子性"></a>使用缓存锁保证原子性</h4><p>在同一时刻，我们只需保证对某个内存地址的操作是原子性即可，但总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化</p>
<p>频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁，在Pentium6和目前的处理器中可以使用“缓存锁定”的方式来实现复杂的原子性</p>
<p>所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其处理器回写已被锁定的缓存行的数据时，会使缓存行无效，在如图2-3所示的例子中，当CPU1修改缓存行中的i时使用了缓存锁定，那么CPU2就不能同时缓存i的缓存行</p>
<p><a name="94efaa83"></a></p>
<h4 id="但是有两种情况下处理器不会使用缓存锁定"><a href="#但是有两种情况下处理器不会使用缓存锁定" class="headerlink" title="但是有两种情况下处理器不会使用缓存锁定"></a>但是有两种情况下处理器不会使用缓存锁定</h4><p>第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定。</p>
<p>第二种情况是：有些处理器不支持缓存锁定。对于Intel486和Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定</p>
<p>针对以上两个机制，我们通过Intel处理器提供了很多Lock前缀的指令来实现。<br>例如</p>
<ul>
<li>位测试和修改指令：BTS、BTR、BTC；</li>
<li>交换指令XADD、CMPXCHG</li>
<li>其他一些操作数和逻辑指令（如ADD、OR）等</li>
</ul>
<p>被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它</p>
<p><a name="e55b71f3"></a></p>
<h3 id="Java如何实现原子操作"><a href="#Java如何实现原子操作" class="headerlink" title="Java如何实现原子操作"></a>Java如何实现原子操作</h3><p>在Java中可以通过锁和循环CAS的方式来实现原子操作</p>
<p><a name="7d28ca79"></a></p>
<h4 id="使用循环CAS实现原子操作"><a href="#使用循环CAS实现原子操作" class="headerlink" title="使用循环CAS实现原子操作"></a>使用循环CAS实现原子操作</h4><p>JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本<br>思路就是循环进行CAS操作直到成功为止</p>
<p><a name="415f5e0c"></a></p>
<h4 id="CAS实现原子操作的三大问题"><a href="#CAS实现原子操作的三大问题" class="headerlink" title="CAS实现原子操作的三大问题"></a>CAS实现原子操作的三大问题</h4><p>在Java并发包中有一些并发框架也使用了自旋CAS的方式来实现原子操作，比如<br>LinkedTransferQueue类的Xfer方法。CAS虽然很高效地解决了原子操作，但是CAS仍然存在三大问题。</p>
<ol>
<li>ABA问题</li>
<li>循环时间长开销大</li>
<li>只能保证一个共享变量的原子操作</li>
</ol>
<p><a name="bddb40ab"></a></p>
<h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><p>因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化<br>则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p>
<p>ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。</p>
<p>JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> compareAndSet &#123;</span><br><span class="line">    V expectedReference, <span class="comment">//预期引用</span></span><br><span class="line">    V newReference, <span class="comment">//更新后的引用</span></span><br><span class="line">    <span class="type">int</span> expectedStamp, <span class="comment">//预期标志</span></span><br><span class="line">    <span class="type">int</span> newStamp; <span class="comment">//更新后的标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a name="ea22956a"></a></p>
<h5 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h5><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升</p>
<ol>
<li>它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零</li>
<li>它可以避免在退出循环的时候因内存顺序冲突（Memory Order Violation）而引起CPU流水线被清空（CPU Pipeline Flush），从而提高CPU的执行效率</li>
</ol>
<p><a name="6e4b8783"></a></p>
<h5 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h5><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁</p>
<p>有一个取巧的办法，就是把多个共享变量合并成一个共享变量来<br>操作</p>
<p><a name="3a2b2045"></a></p>
<h4 id="使用锁机制实现原子操作"><a href="#使用锁机制实现原子操作" class="headerlink" title="使用锁机制实现原子操作"></a>使用锁机制实现原子操作</h4><p>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ohyesc.github.io">Li Jing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ohyesc.github.io/2023/11/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/2.%20%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-viou04-ttxn1n/">https://ohyesc.github.io/2023/11/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/2.%20%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-viou04-ttxn1n/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ohyesc.github.io" target="_blank">我的生活小站</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/">并发编程的艺术</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/11/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/1.%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%8C%91%E6%88%98-viou04-fw3b98/" title="1. 并发编程挑战"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">1. 并发编程挑战</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/1.%20JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-viou04-rzo3ek/" title="1. JAVA内存模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">1. JAVA内存模型</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/11/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/1.%20JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-viou04-rzo3ek/" title="1. JAVA内存模型"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-20</div><div class="title">1. JAVA内存模型</div></div></a></div><div><a href="/2023/11/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/1.%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%8C%91%E6%88%98-viou04-fw3b98/" title="1. 并发编程挑战"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-20</div><div class="title">1. 并发编程挑战</div></div></a></div><div><a href="/2023/11/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/2.%20%E9%87%8D%E6%8E%92%E5%BA%8F-viou04-ywfe9o/" title="2. 重排序"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-20</div><div class="title">2. 重排序</div></div></a></div><div><a href="/2023/11/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/3.%20%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7-viou04-oxmkf1/" title="3. 顺序一致性"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-20</div><div class="title">3. 顺序一致性</div></div></a></div><div><a href="/2023/11/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/4.%20volatile%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89-viou04-sqnkhn/" title="4. volatile的内存语义"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-20</div><div class="title">4. volatile的内存语义</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Li Jing</div><div class="author-info__description">这是一个老父亲答应给孩子建个网站，记录一下他的成长</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">125</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">volatile的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E5%AE%9A%E4%B9%89%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">volatile定义和原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%88%99%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">volatile实现原则：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BC%98%E5%8C%96%EF%BC%9A"><span class="toc-number">1.1.2.</span> <span class="toc-text">volatile的使用优化：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%BD%E5%8A%A0%E5%AD%97%E8%8A%82%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">追加字节能优化性能？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%BD%E5%8A%A064%E5%AD%97%E8%8A%82%E8%83%BD%E5%A4%9F%E6%8F%90%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%95%88%E7%8E%87%E5%91%A2%EF%BC%9F"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">为什么追加64字节能够提高并发编程的效率呢？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%82%A3%E4%B9%88%E6%98%AF%E4%B8%8D%E6%98%AF%E5%9C%A8%E4%BD%BF%E7%94%A8volatile%E5%8F%98%E9%87%8F%E6%97%B6%E9%83%BD%E5%BA%94%E8%AF%A5%E8%BF%BD%E5%8A%A0%E5%88%B064%E5%AD%97%E8%8A%82%E5%91%A2%EF%BC%9F"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">那么是不是在使用volatile变量时都应该追加到64字节呢？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%A1%8C%E9%9D%9E64%E5%AD%97%E8%8A%82%E5%AE%BD%E7%9A%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.1.2.3.1.</span> <span class="toc-text">缓存行非64字节宽的处理器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E4%B8%8D%E4%BC%9A%E8%A2%AB%E9%A2%91%E7%B9%81%E5%9C%B0%E5%86%99%E3%80%82"><span class="toc-number">1.1.2.3.2.</span> <span class="toc-text">共享变量不会被频繁地写。</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">synchronized的实现原理与应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">2.1.</span> <span class="toc-text">Java对象头</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E4%BD%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C64%E4%BD%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-number">2.1.1.</span> <span class="toc-text">32位虚拟机和64位虚拟机对象头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JAVA%E5%AF%B9%E8%B1%A1%E5%A4%B4%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.2.</span> <span class="toc-text">JAVA对象头存储结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8C%87%E9%92%88"><span class="toc-number">2.2.</span> <span class="toc-text">类型指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE"><span class="toc-number">2.3.</span> <span class="toc-text">实例数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85"><span class="toc-number">2.4.</span> <span class="toc-text">对齐填充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="toc-number">2.5.</span> <span class="toc-text">锁的升级与对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">2.5.1.</span> <span class="toc-text">偏向锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%92%A4%E9%94%80"><span class="toc-number">2.5.1.0.1.</span> <span class="toc-text">偏向锁的撤销</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">2.5.1.0.2.</span> <span class="toc-text">关闭偏向锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">2.5.2.</span> <span class="toc-text">轻量级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%8A%A0%E9%94%81"><span class="toc-number">2.5.2.1.</span> <span class="toc-text">轻量级锁加锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E8%A7%A3%E9%94%81"><span class="toc-number">2.5.2.2.</span> <span class="toc-text">轻量级锁解锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94"><span class="toc-number">2.5.3.</span> <span class="toc-text">锁的优缺点对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">原子操作的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E6%9C%AF%E8%AF%AD%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">CPU术语定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.</span> <span class="toc-text">处理器如何实现原子操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BA%BF%E9%94%81%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">3.2.1.</span> <span class="toc-text">使用总线锁保证原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E9%94%81%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">3.2.2.</span> <span class="toc-text">使用缓存锁保证原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%86%E6%98%AF%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%83%85%E5%86%B5%E4%B8%8B%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%8D%E4%BC%9A%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E9%94%81%E5%AE%9A"><span class="toc-number">3.2.3.</span> <span class="toc-text">但是有两种情况下处理器不会使用缓存锁定</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.</span> <span class="toc-text">Java如何实现原子操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BE%AA%E7%8E%AFCAS%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.1.</span> <span class="toc-text">使用循环CAS实现原子操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.2.</span> <span class="toc-text">CAS实现原子操作的三大问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ABA%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">ABA问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%97%B6%E9%97%B4%E9%95%BF%E5%BC%80%E9%94%80%E5%A4%A7"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">循环时间长开销大</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AA%E8%83%BD%E4%BF%9D%E8%AF%81%E4%B8%80%E4%B8%AA%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">只能保证一个共享变量的原子操作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%94%81%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.3.</span> <span class="toc-text">使用锁机制实现原子操作</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/20/Mybatis/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/1.%20%E9%85%8D%E7%BD%AE%E2%BD%82%E4%BB%B6%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90-hyw7ef-geagn5/" title="1. 配置⽂件解析过程分析">1. 配置⽂件解析过程分析</a><time datetime="2023-11-20T01:36:07.251Z" title="发表于 2023-11-20 09:36:07">2023-11-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/20/Mybatis/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/2.%20%E8%A7%A3%E6%9E%90properties%E8%8A%82%E7%82%B9-hyw7ef-er4viw/" title="2. 解析properties节点">2. 解析properties节点</a><time datetime="2023-11-20T01:36:06.717Z" title="发表于 2023-11-20 09:36:06">2023-11-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/20/Mybatis/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/3.%20%E8%A7%A3%E6%9E%90settings%E8%8A%82%E7%82%B9-hyw7ef-diq3xg/" title="3. 解析settings节点">3. 解析settings节点</a><time datetime="2023-11-20T01:36:06.171Z" title="发表于 2023-11-20 09:36:06">2023-11-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/20/Mybatis/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/4.%20%E8%AE%BE%E7%BD%AEsettings%E5%86%85%E5%AE%B9%E5%88%B0%20Configuration%E4%B8%AD-hyw7ef-axg91r/" title="4. 设置settings内容到 Configuration中">4. 设置settings内容到 Configuration中</a><time datetime="2023-11-20T01:36:05.477Z" title="发表于 2023-11-20 09:36:05">2023-11-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/20/Mybatis/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B/5.%20%E8%A7%A3%E6%9E%90typeAliases%E8%8A%82%E7%82%B9-hyw7ef-txspfu/" title="5. 解析typeAliases节点">5. 解析typeAliases节点</a><time datetime="2023-11-20T01:36:05.110Z" title="发表于 2023-11-20 09:36:05">2023-11-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Li Jing</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>